// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class CommitteeDecision extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CommitteeDecision entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type CommitteeDecision must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CommitteeDecision", id.toString(), this);
    }
  }

  static load(id: string): CommitteeDecision | null {
    return changetype<CommitteeDecision | null>(
      store.get("CommitteeDecision", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get decision(): boolean {
    let value = this.get("decision");
    return value!.toBoolean();
  }

  set decision(value: boolean) {
    this.set("decision", Value.fromBoolean(value));
  }
}

export class CommitteeVote extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CommitteeVote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CommitteeVote must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CommitteeVote", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CommitteeVote | null {
    return changetype<CommitteeVote | null>(
      store.get("CommitteeVote", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get committeeMember(): Bytes {
    let value = this.get("committeeMember");
    return value!.toBytes();
  }

  set committeeMember(value: Bytes) {
    this.set("committeeMember", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get decision(): boolean {
    let value = this.get("decision");
    return value!.toBoolean();
  }

  set decision(value: boolean) {
    this.set("decision", Value.fromBoolean(value));
  }

  get _NFT_uri(): string {
    let value = this.get("_NFT_uri");
    return value!.toString();
  }

  set _NFT_uri(value: string) {
    this.set("_NFT_uri", Value.fromString(value));
  }

  get _NFT_owner(): Bytes {
    let value = this.get("_NFT_owner");
    return value!.toBytes();
  }

  set _NFT_owner(value: Bytes) {
    this.set("_NFT_owner", Value.fromBytes(value));
  }

  get _NFT_approvedVotes(): BigInt {
    let value = this.get("_NFT_approvedVotes");
    return value!.toBigInt();
  }

  set _NFT_approvedVotes(value: BigInt) {
    this.set("_NFT_approvedVotes", Value.fromBigInt(value));
  }

  get _NFT_rejectedVotes(): BigInt {
    let value = this.get("_NFT_rejectedVotes");
    return value!.toBigInt();
  }

  set _NFT_rejectedVotes(value: BigInt) {
    this.set("_NFT_rejectedVotes", Value.fromBigInt(value));
  }

  get _NFT_isApprovedByCommittee(): boolean {
    let value = this.get("_NFT_isApprovedByCommittee");
    return value!.toBoolean();
  }

  set _NFT_isApprovedByCommittee(value: boolean) {
    this.set("_NFT_isApprovedByCommittee", Value.fromBoolean(value));
  }

  get _NFT_rejected(): boolean {
    let value = this.get("_NFT_rejected");
    return value!.toBoolean();
  }

  set _NFT_rejected(value: boolean) {
    this.set("_NFT_rejected", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Initialized extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Initialized entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Initialized must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Initialized", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Initialized | null {
    return changetype<Initialized | null>(
      store.get("Initialized", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NftAdded extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NftAdded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NftAdded must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NftAdded", id.toString(), this);
    }
  }

  static load(id: string): NftAdded | null {
    return changetype<NftAdded | null>(store.get("NftAdded", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get NFT_uri(): string {
    let value = this.get("NFT_uri");
    return value!.toString();
  }

  set NFT_uri(value: string) {
    this.set("NFT_uri", Value.fromString(value));
  }

  get NFT_owner(): Bytes {
    let value = this.get("NFT_owner");
    return value!.toBytes();
  }

  set NFT_owner(value: Bytes) {
    this.set("NFT_owner", Value.fromBytes(value));
  }

  get NFT_approvedVotes(): BigInt {
    let value = this.get("NFT_approvedVotes");
    return value!.toBigInt();
  }

  set NFT_approvedVotes(value: BigInt) {
    this.set("NFT_approvedVotes", Value.fromBigInt(value));
  }

  get NFT_rejectedVotes(): BigInt {
    let value = this.get("NFT_rejectedVotes");
    return value!.toBigInt();
  }

  set NFT_rejectedVotes(value: BigInt) {
    this.set("NFT_rejectedVotes", Value.fromBigInt(value));
  }

  get NFT_isApprovedByCommittee(): boolean {
    let value = this.get("NFT_isApprovedByCommittee");
    return value!.toBoolean();
  }

  set NFT_isApprovedByCommittee(value: boolean) {
    this.set("NFT_isApprovedByCommittee", Value.fromBoolean(value));
  }

  get NFT_rejected(): boolean {
    let value = this.get("NFT_rejected");
    return value!.toBoolean();
  }

  set NFT_rejected(value: boolean) {
    this.set("NFT_rejected", Value.fromBoolean(value));
  }

  get uploadTime(): BigInt {
    let value = this.get("uploadTime");
    return value!.toBigInt();
  }

  set uploadTime(value: BigInt) {
    this.set("uploadTime", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get adminVotes(): Array<string> {
    let value = this.get("adminVotes");
    return value!.toStringArray();
  }

  set adminVotes(value: Array<string>) {
    this.set("adminVotes", Value.fromStringArray(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnershipTransferred", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DaoPublicInitialized extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DaoPublicInitialized entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DaoPublicInitialized must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DaoPublicInitialized", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): DaoPublicInitialized | null {
    return changetype<DaoPublicInitialized | null>(
      store.get("DaoPublicInitialized", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get version(): i32 {
    let value = this.get("version");
    return value!.toI32();
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NftApproved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NftApproved entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NftApproved must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NftApproved", id.toString(), this);
    }
  }

  static load(id: string): NftApproved | null {
    return changetype<NftApproved | null>(store.get("NftApproved", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get _NFT_uri(): string {
    let value = this.get("_NFT_uri");
    return value!.toString();
  }

  set _NFT_uri(value: string) {
    this.set("_NFT_uri", Value.fromString(value));
  }

  get _NFT_owner(): Bytes {
    let value = this.get("_NFT_owner");
    return value!.toBytes();
  }

  set _NFT_owner(value: Bytes) {
    this.set("_NFT_owner", Value.fromBytes(value));
  }

  get _NFT_index(): BigInt {
    let value = this.get("_NFT_index");
    return value!.toBigInt();
  }

  set _NFT_index(value: BigInt) {
    this.set("_NFT_index", Value.fromBigInt(value));
  }

  get _NFT_votes(): BigInt {
    let value = this.get("_NFT_votes");
    return value!.toBigInt();
  }

  set _NFT_votes(value: BigInt) {
    this.set("_NFT_votes", Value.fromBigInt(value));
  }

  get _NFT_winTime(): BigInt {
    let value = this.get("_NFT_winTime");
    return value!.toBigInt();
  }

  set _NFT_winTime(value: BigInt) {
    this.set("_NFT_winTime", Value.fromBigInt(value));
  }

  get _NFT_votersCount(): BigInt {
    let value = this.get("_NFT_votersCount");
    return value!.toBigInt();
  }

  set _NFT_votersCount(value: BigInt) {
    this.set("_NFT_votersCount", Value.fromBigInt(value));
  }

  get _NFT_favourVotes(): BigInt {
    let value = this.get("_NFT_favourVotes");
    return value!.toBigInt();
  }

  set _NFT_favourVotes(value: BigInt) {
    this.set("_NFT_favourVotes", Value.fromBigInt(value));
  }

  get _NFT_disApprovedVotes(): BigInt {
    let value = this.get("_NFT_disApprovedVotes");
    return value!.toBigInt();
  }

  set _NFT_disApprovedVotes(value: BigInt) {
    this.set("_NFT_disApprovedVotes", Value.fromBigInt(value));
  }

  get _NFT_isApprovedByCommittee(): boolean {
    let value = this.get("_NFT_isApprovedByCommittee");
    return value!.toBoolean();
  }

  set _NFT_isApprovedByCommittee(value: boolean) {
    this.set("_NFT_isApprovedByCommittee", Value.fromBoolean(value));
  }

  get _NFT_winnerStatus(): boolean {
    let value = this.get("_NFT_winnerStatus");
    return value!.toBoolean();
  }

  set _NFT_winnerStatus(value: boolean) {
    this.set("_NFT_winnerStatus", Value.fromBoolean(value));
  }

  get _NFT_isBlackListed(): boolean {
    let value = this.get("_NFT_isBlackListed");
    return value!.toBoolean();
  }

  set _NFT_isBlackListed(value: boolean) {
    this.set("_NFT_isBlackListed", Value.fromBoolean(value));
  }

  get startTime(): BigInt {
    let value = this.get("startTime");
    return value!.toBigInt();
  }

  set startTime(value: BigInt) {
    this.set("startTime", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get publicVotes(): Array<Bytes> {
    let value = this.get("publicVotes");
    return value!.toBytesArray();
  }

  set publicVotes(value: Array<Bytes>) {
    this.set("publicVotes", Value.fromBytesArray(value));
  }

  get adminVotes(): Array<string> {
    let value = this.get("adminVotes");
    return value!.toStringArray();
  }

  set adminVotes(value: Array<string>) {
    this.set("adminVotes", Value.fromStringArray(value));
  }
}

export class DaoPublicOwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DaoPublicOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type DaoPublicOwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set(
        "DaoPublicOwnershipTransferred",
        id.toBytes().toHexString(),
        this
      );
    }
  }

  static load(id: Bytes): DaoPublicOwnershipTransferred | null {
    return changetype<DaoPublicOwnershipTransferred | null>(
      store.get("DaoPublicOwnershipTransferred", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PublicVote extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PublicVote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PublicVote must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PublicVote", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PublicVote | null {
    return changetype<PublicVote | null>(
      store.get("PublicVote", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get voter(): Bytes {
    let value = this.get("voter");
    return value!.toBytes();
  }

  set voter(value: Bytes) {
    this.set("voter", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get _NFT_uri(): string {
    let value = this.get("_NFT_uri");
    return value!.toString();
  }

  set _NFT_uri(value: string) {
    this.set("_NFT_uri", Value.fromString(value));
  }

  get _NFT_owner(): Bytes {
    let value = this.get("_NFT_owner");
    return value!.toBytes();
  }

  set _NFT_owner(value: Bytes) {
    this.set("_NFT_owner", Value.fromBytes(value));
  }

  get _NFT_index(): BigInt {
    let value = this.get("_NFT_index");
    return value!.toBigInt();
  }

  set _NFT_index(value: BigInt) {
    this.set("_NFT_index", Value.fromBigInt(value));
  }

  get _NFT_votes(): BigInt {
    let value = this.get("_NFT_votes");
    return value!.toBigInt();
  }

  set _NFT_votes(value: BigInt) {
    this.set("_NFT_votes", Value.fromBigInt(value));
  }

  get _NFT_winTime(): BigInt {
    let value = this.get("_NFT_winTime");
    return value!.toBigInt();
  }

  set _NFT_winTime(value: BigInt) {
    this.set("_NFT_winTime", Value.fromBigInt(value));
  }

  get _NFT_votersCount(): BigInt {
    let value = this.get("_NFT_votersCount");
    return value!.toBigInt();
  }

  set _NFT_votersCount(value: BigInt) {
    this.set("_NFT_votersCount", Value.fromBigInt(value));
  }

  get _NFT_favourVotes(): BigInt {
    let value = this.get("_NFT_favourVotes");
    return value!.toBigInt();
  }

  set _NFT_favourVotes(value: BigInt) {
    this.set("_NFT_favourVotes", Value.fromBigInt(value));
  }

  get _NFT_disApprovedVotes(): BigInt {
    let value = this.get("_NFT_disApprovedVotes");
    return value!.toBigInt();
  }

  set _NFT_disApprovedVotes(value: BigInt) {
    this.set("_NFT_disApprovedVotes", Value.fromBigInt(value));
  }

  get _NFT_isApprovedByCommittee(): boolean {
    let value = this.get("_NFT_isApprovedByCommittee");
    return value!.toBoolean();
  }

  set _NFT_isApprovedByCommittee(value: boolean) {
    this.set("_NFT_isApprovedByCommittee", Value.fromBoolean(value));
  }

  get _NFT_winnerStatus(): boolean {
    let value = this.get("_NFT_winnerStatus");
    return value!.toBoolean();
  }

  set _NFT_winnerStatus(value: boolean) {
    this.set("_NFT_winnerStatus", Value.fromBoolean(value));
  }

  get _NFT_isBlackListed(): boolean {
    let value = this.get("_NFT_isBlackListed");
    return value!.toBoolean();
  }

  set _NFT_isBlackListed(value: boolean) {
    this.set("_NFT_isBlackListed", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Winner extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Winner entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Winner must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Winner", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Winner | null {
    return changetype<Winner | null>(store.get("Winner", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get _NFT_uri(): string {
    let value = this.get("_NFT_uri");
    return value!.toString();
  }

  set _NFT_uri(value: string) {
    this.set("_NFT_uri", Value.fromString(value));
  }

  get _NFT_owner(): Bytes {
    let value = this.get("_NFT_owner");
    return value!.toBytes();
  }

  set _NFT_owner(value: Bytes) {
    this.set("_NFT_owner", Value.fromBytes(value));
  }

  get _NFT_index(): BigInt {
    let value = this.get("_NFT_index");
    return value!.toBigInt();
  }

  set _NFT_index(value: BigInt) {
    this.set("_NFT_index", Value.fromBigInt(value));
  }

  get _NFT_votes(): BigInt {
    let value = this.get("_NFT_votes");
    return value!.toBigInt();
  }

  set _NFT_votes(value: BigInt) {
    this.set("_NFT_votes", Value.fromBigInt(value));
  }

  get _NFT_winTime(): BigInt {
    let value = this.get("_NFT_winTime");
    return value!.toBigInt();
  }

  set _NFT_winTime(value: BigInt) {
    this.set("_NFT_winTime", Value.fromBigInt(value));
  }

  get _NFT_votersCount(): BigInt {
    let value = this.get("_NFT_votersCount");
    return value!.toBigInt();
  }

  set _NFT_votersCount(value: BigInt) {
    this.set("_NFT_votersCount", Value.fromBigInt(value));
  }

  get _NFT_favourVotes(): BigInt {
    let value = this.get("_NFT_favourVotes");
    return value!.toBigInt();
  }

  set _NFT_favourVotes(value: BigInt) {
    this.set("_NFT_favourVotes", Value.fromBigInt(value));
  }

  get _NFT_disApprovedVotes(): BigInt {
    let value = this.get("_NFT_disApprovedVotes");
    return value!.toBigInt();
  }

  set _NFT_disApprovedVotes(value: BigInt) {
    this.set("_NFT_disApprovedVotes", Value.fromBigInt(value));
  }

  get _NFT_isApprovedByCommittee(): boolean {
    let value = this.get("_NFT_isApprovedByCommittee");
    return value!.toBoolean();
  }

  set _NFT_isApprovedByCommittee(value: boolean) {
    this.set("_NFT_isApprovedByCommittee", Value.fromBoolean(value));
  }

  get _NFT_winnerStatus(): boolean {
    let value = this.get("_NFT_winnerStatus");
    return value!.toBoolean();
  }

  set _NFT_winnerStatus(value: boolean) {
    this.set("_NFT_winnerStatus", Value.fromBoolean(value));
  }

  get _NFT_isBlackListed(): boolean {
    let value = this.get("_NFT_isBlackListed");
    return value!.toBoolean();
  }

  set _NFT_isBlackListed(value: boolean) {
    this.set("_NFT_isBlackListed", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class blackListed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save blackListed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type blackListed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("blackListed", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): blackListed | null {
    return changetype<blackListed | null>(
      store.get("blackListed", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get decision(): boolean {
    let value = this.get("decision");
    return value!.toBoolean();
  }

  set decision(value: boolean) {
    this.set("decision", Value.fromBoolean(value));
  }

  get _NFT_uri(): string {
    let value = this.get("_NFT_uri");
    return value!.toString();
  }

  set _NFT_uri(value: string) {
    this.set("_NFT_uri", Value.fromString(value));
  }

  get _NFT_owner(): Bytes {
    let value = this.get("_NFT_owner");
    return value!.toBytes();
  }

  set _NFT_owner(value: Bytes) {
    this.set("_NFT_owner", Value.fromBytes(value));
  }

  get _NFT_index(): BigInt {
    let value = this.get("_NFT_index");
    return value!.toBigInt();
  }

  set _NFT_index(value: BigInt) {
    this.set("_NFT_index", Value.fromBigInt(value));
  }

  get _NFT_votes(): BigInt {
    let value = this.get("_NFT_votes");
    return value!.toBigInt();
  }

  set _NFT_votes(value: BigInt) {
    this.set("_NFT_votes", Value.fromBigInt(value));
  }

  get _NFT_winTime(): BigInt {
    let value = this.get("_NFT_winTime");
    return value!.toBigInt();
  }

  set _NFT_winTime(value: BigInt) {
    this.set("_NFT_winTime", Value.fromBigInt(value));
  }

  get _NFT_votersCount(): BigInt {
    let value = this.get("_NFT_votersCount");
    return value!.toBigInt();
  }

  set _NFT_votersCount(value: BigInt) {
    this.set("_NFT_votersCount", Value.fromBigInt(value));
  }

  get _NFT_favourVotes(): BigInt {
    let value = this.get("_NFT_favourVotes");
    return value!.toBigInt();
  }

  set _NFT_favourVotes(value: BigInt) {
    this.set("_NFT_favourVotes", Value.fromBigInt(value));
  }

  get _NFT_disApprovedVotes(): BigInt {
    let value = this.get("_NFT_disApprovedVotes");
    return value!.toBigInt();
  }

  set _NFT_disApprovedVotes(value: BigInt) {
    this.set("_NFT_disApprovedVotes", Value.fromBigInt(value));
  }

  get _NFT_isApprovedByCommittee(): boolean {
    let value = this.get("_NFT_isApprovedByCommittee");
    return value!.toBoolean();
  }

  set _NFT_isApprovedByCommittee(value: boolean) {
    this.set("_NFT_isApprovedByCommittee", Value.fromBoolean(value));
  }

  get _NFT_winnerStatus(): boolean {
    let value = this.get("_NFT_winnerStatus");
    return value!.toBoolean();
  }

  set _NFT_winnerStatus(value: boolean) {
    this.set("_NFT_winnerStatus", Value.fromBoolean(value));
  }

  get _NFT_isBlackListed(): boolean {
    let value = this.get("_NFT_isBlackListed");
    return value!.toBoolean();
  }

  set _NFT_isBlackListed(value: boolean) {
    this.set("_NFT_isBlackListed", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class claimed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save claimed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type claimed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("claimed", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): claimed | null {
    return changetype<claimed | null>(store.get("claimed", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get claimedBy(): Bytes {
    let value = this.get("claimedBy");
    return value!.toBytes();
  }

  set claimedBy(value: Bytes) {
    this.set("claimedBy", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get claimTime(): BigInt {
    let value = this.get("claimTime");
    return value!.toBigInt();
  }

  set claimTime(value: BigInt) {
    this.set("claimTime", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class voteForBlackList extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save voteForBlackList entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type voteForBlackList must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("voteForBlackList", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): voteForBlackList | null {
    return changetype<voteForBlackList | null>(
      store.get("voteForBlackList", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get committeeMember(): Bytes {
    let value = this.get("committeeMember");
    return value!.toBytes();
  }

  set committeeMember(value: Bytes) {
    this.set("committeeMember", Value.fromBytes(value));
  }

  get index(): BigInt {
    let value = this.get("index");
    return value!.toBigInt();
  }

  set index(value: BigInt) {
    this.set("index", Value.fromBigInt(value));
  }

  get decision(): boolean {
    let value = this.get("decision");
    return value!.toBoolean();
  }

  set decision(value: boolean) {
    this.set("decision", Value.fromBoolean(value));
  }

  get _NFT_uri(): string {
    let value = this.get("_NFT_uri");
    return value!.toString();
  }

  set _NFT_uri(value: string) {
    this.set("_NFT_uri", Value.fromString(value));
  }

  get _NFT_owner(): Bytes {
    let value = this.get("_NFT_owner");
    return value!.toBytes();
  }

  set _NFT_owner(value: Bytes) {
    this.set("_NFT_owner", Value.fromBytes(value));
  }

  get _NFT_index(): BigInt {
    let value = this.get("_NFT_index");
    return value!.toBigInt();
  }

  set _NFT_index(value: BigInt) {
    this.set("_NFT_index", Value.fromBigInt(value));
  }

  get _NFT_votes(): BigInt {
    let value = this.get("_NFT_votes");
    return value!.toBigInt();
  }

  set _NFT_votes(value: BigInt) {
    this.set("_NFT_votes", Value.fromBigInt(value));
  }

  get _NFT_winTime(): BigInt {
    let value = this.get("_NFT_winTime");
    return value!.toBigInt();
  }

  set _NFT_winTime(value: BigInt) {
    this.set("_NFT_winTime", Value.fromBigInt(value));
  }

  get _NFT_votersCount(): BigInt {
    let value = this.get("_NFT_votersCount");
    return value!.toBigInt();
  }

  set _NFT_votersCount(value: BigInt) {
    this.set("_NFT_votersCount", Value.fromBigInt(value));
  }

  get _NFT_favourVotes(): BigInt {
    let value = this.get("_NFT_favourVotes");
    return value!.toBigInt();
  }

  set _NFT_favourVotes(value: BigInt) {
    this.set("_NFT_favourVotes", Value.fromBigInt(value));
  }

  get _NFT_disApprovedVotes(): BigInt {
    let value = this.get("_NFT_disApprovedVotes");
    return value!.toBigInt();
  }

  set _NFT_disApprovedVotes(value: BigInt) {
    this.set("_NFT_disApprovedVotes", Value.fromBigInt(value));
  }

  get _NFT_isApprovedByCommittee(): boolean {
    let value = this.get("_NFT_isApprovedByCommittee");
    return value!.toBoolean();
  }

  set _NFT_isApprovedByCommittee(value: boolean) {
    this.set("_NFT_isApprovedByCommittee", Value.fromBoolean(value));
  }

  get _NFT_winnerStatus(): boolean {
    let value = this.get("_NFT_winnerStatus");
    return value!.toBoolean();
  }

  set _NFT_winnerStatus(value: boolean) {
    this.set("_NFT_winnerStatus", Value.fromBoolean(value));
  }

  get _NFT_isBlackListed(): boolean {
    let value = this.get("_NFT_isBlackListed");
    return value!.toBoolean();
  }

  set _NFT_isBlackListed(value: boolean) {
    this.set("_NFT_isBlackListed", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}
